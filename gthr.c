#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h> 

#include "gthr.h"
#include "gthr_struct.h"

// function triggered periodically by timer (SIGALRM)
void gthandle(int sig) {
  gtyield();
}

// initialize first thread as current context
void gtinit(int type, int priority, int a, int b, int thr_id) {
  gtcur = & gttbl[0];			// initialize current thread with thread #0
  gtcur -> st = Running;		// set current to running
  
  // thread is running, start run clock
  clock_gettime(CLOCK_MONOTONIC_RAW, &gtcur->startRunClock);
  
  // set up default values
  gtcur -> totalRunTime = 0.0;
  gtcur -> minRunTime = 99999.0;
  gtcur -> maxRunTime = 0.0;
  gtcur -> countRunAvg = 0;
  gtcur -> totalWaitTime = 0.0;
  gtcur -> minWaitTime = 99999.0;
  gtcur -> maxWaitTime = 0.0;
  gtcur -> countWaitAvg = 0;
  
  gtcur -> priority = priority;
  gtcur -> actualPriority = priority;
  
  gtcur -> tickets[0] = a;
	gtcur -> tickets[1] = b;

  gtcur -> thr_id = thr_id;
	
	stype = type;
  
  signal(SIGALRM, gthandle);	// register SIGALRM, signal from timer generated by alarm
}

// exit thread
void __attribute__((noreturn)) gtret(int ret) {
  if (gtcur != & gttbl[0]) {	// if not an initial thread,
    gtcur -> st = Unused;		// set current thread as unused
    gtyield();					// yield and make possible to switch to another thread
    assert(!"reachable");		// this code should never be reachable ... (if yes, returning function on stack was corrupted)
  }
  while (gtyield());			// if initial thread, wait for other to terminate
  exit(ret);
}

// switch from one thread to other
bool gtyield(void) {
  struct gt * p;
  struct gtctx * old, * new;

  resetsig(SIGALRM);			// reset signal

  p = gtcur;
  
  if (stype == 1) { // rr
		while (p -> st != Ready) {
		  if (++p == & gttbl[MaxGThreads])
	    	p = & gttbl[0];
		  if (p == gtcur)
	    	return false;
		}
  }
  
  else if (stype == 2) { // pri
		while (true) {
			if (p->st == Ready && p->actualPriority <= 0) {
		  	break;
			}
			else {
				p->actualPriority--;
			}
		  if (++p == & gttbl[MaxGThreads])
		    p = & gttbl[0];
		}
	 	p->actualPriority = p->priority;
	}
	
	else if (stype == 3) { // ls
		int randomTicket = rand() % 101;
		
		while (p -> st != Ready) {
			if (randomTicket >= p->tickets[0] && randomTicket <= p->tickets[1])
				break;
		  if (++p == & gttbl[MaxGThreads])
	    	p = & gttbl[0];
		  if (p == gtcur)
	    	return false;
		}
	}

  if (gtcur -> st != Unused) {			// switch current to Ready and new thread found in previous loop to Running
    gtcur -> st = Ready;
  }
  
  // stop run time of previous thread
  clock_gettime(CLOCK_MONOTONIC_RAW, &gtcur->endRunClock);
  uint64_t time = (double)(gtcur->endRunClock.tv_sec - gtcur->startRunClock.tv_sec) * 1000000 + (double)(gtcur->endRunClock.tv_nsec - gtcur->startRunClock.tv_nsec) / 1000;
  double timeSec = (double)time / 1000000;
  gtcur->totalRunTime += timeSec;
  gtcur->countRunAvg++;
  
  if (timeSec < gtcur->minRunTime) {
     gtcur->minRunTime = timeSec;
  }
  if (timeSec > gtcur->maxRunTime) {
     gtcur->maxRunTime = timeSec;
  }
  
  // start wait time of previous thread
  clock_gettime(CLOCK_MONOTONIC_RAW, &gtcur->startWaitClock);
  
  p -> st = Running;
  if (p->totalRunTime >= 3.0 && p->totalRunTime <= 3.1) {
    resetStats2(p->thr_id);
    setpriority(p->thr_id, 0);
    //sleep(3000);
    //printStats();
    //exit(0);
  }

  // stop wait time of new thread
  clock_gettime(CLOCK_MONOTONIC_RAW, &p->endWaitClock);
  uint64_t time2 = (double)(p->endWaitClock.tv_sec - p->startWaitClock.tv_sec) * 1000000 + (double)(p->endWaitClock.tv_nsec - p->startWaitClock.tv_nsec) / 1000;
  double timeSec2 = (double)time2 / 1000000;
  p->totalWaitTime += timeSec2;
  p->countWaitAvg++;
  
  if (timeSec2 < p->minWaitTime) {
     p->minWaitTime = timeSec2;
  }
  if (timeSec2 > p->maxWaitTime) {
     p->maxWaitTime = timeSec2;
  }
  
  // start run time of new thread
  clock_gettime(CLOCK_MONOTONIC_RAW, &p->startRunClock);
  
  old = & gtcur -> ctx;					// prepare pointers to context of current (will become old) 
  new = & p -> ctx;						// and new to new thread found in previous loop
  gtcur = p;							// switch current indicator to new thread
  gtswtch(old, new);					// perform context switch (assembly in gtswtch.S)
  
  return true;
}

// return function for terminating thread
void gtstop(void) {
  gtret(0);
}

// create new thread by providing pointer to function that will act like "run" method
int gtgo(void( * f)(void), int priority, int a, int b, int thr_id) {
  char * stack;
  struct gt * p;

  for (p = & gttbl[0];; p++)			// find an empty slot
    if (p == & gttbl[MaxGThreads])		// if we have reached the end, gttbl is full and we cannot create a new thread
      return -1;
    else if (p -> st == Unused)
      break;								// new slot was found

  stack = malloc(StackSize);			// allocate memory for stack of newly created thread
  if (!stack)
    return -1;

  *(uint64_t * ) & stack[StackSize - 8] = (uint64_t) gtstop;	//	put into the stack returning function gtstop in case function calls return
  *(uint64_t * ) & stack[StackSize - 16] = (uint64_t) f;		//  put provided function as a main "run" function
  p -> ctx.rsp = (uint64_t) & stack[StackSize - 16];			//  set stack pointer
  p -> st = Ready;												//  set state

  // thread is ready, start wait clock
  clock_gettime(CLOCK_MONOTONIC_RAW, &p->startWaitClock);
  
  // set up default values
  p -> totalRunTime = 0.0;
  p -> minRunTime = 99999.0;
  p -> maxRunTime = 0.0;
  p -> countRunAvg = 0;
  p -> totalWaitTime = 0.0;
  p -> minWaitTime = 99999.0;
  p -> maxWaitTime = 0.0;
  p -> countWaitAvg = 0;
  
  p -> priority = priority;
  p -> actualPriority = priority;
 
  p -> tickets[0] = a;
	p -> tickets[1] = b;

  p -> thr_id = thr_id;
  if (thr_id == 4) {
    tSleep(10000);
  }
  
  return 0;
}

void resetsig(int sig) {
  if (sig == SIGALRM) {
    alarm(0);			// Clear pending alarms if any
  }

  sigset_t set;				// Create signal set
  sigemptyset( & set);		// Clear it
  sigaddset( & set, sig);	// Set signal (we use SIGALRM)

  sigprocmask(SIG_UNBLOCK, & set, NULL);	// Fetch and change the signal mask

  if (sig == SIGALRM) {
    // Generate alarms
    ualarm(500, 500);		// Schedule signal after given number of microseconds
  }
}

int uninterruptibleNanoSleep(time_t sec, long nanosec) {
  struct timespec req;
  req.tv_sec = sec;
  req.tv_nsec = nanosec;

  do {
    if (0 != nanosleep( & req, & req)) {
      if (errno != EINTR)
        return -1;
    } else {
      break;
    }
  } while (req.tv_sec > 0 || req.tv_nsec > 0);
  return 0; /* Return success */
}

void setpriority(int thr_id, int prio) {
  for (int i = 0; i < MaxGThreads; i++) {
    if (gttbl[i].thr_id == thr_id) {
      gttbl[i].priority = prio;
      gttbl[i].actualPriority = prio;
    }
  }
}

void tSleep(int ms) {
  gtcur->st = Stopped;
  //sleep(ms/1000);
  //gtcur->st = Ready;
}

void resetStats() {
  for (int i = 0; i < MaxGThreads; i++) {
    // set up default values
    gttbl[i].totalRunTime = 0.0;
    gttbl[i].minRunTime = 99999.0;
    gttbl[i].maxRunTime = 0.0;
    gttbl[i].countRunAvg = 0;
    gttbl[i].totalWaitTime = 0.0;
    gttbl[i].minWaitTime = 99999.0;
    gttbl[i].maxWaitTime = 0.0;
    gttbl[i].countWaitAvg = 0;
  }
}
void resetStats2(int thr_id) {
  for (int i = 0; i < MaxGThreads; i++) {
    if (gttbl[i].thr_id == thr_id) {
      gttbl[i].totalRunTime = 0.0;
      gttbl[i].minRunTime = 99999.0;
      gttbl[i].maxRunTime = 0.0;
      gttbl[i].countRunAvg = 0;
      gttbl[i].totalWaitTime = 0.0;
      gttbl[i].minWaitTime = 99999.0;
      gttbl[i].maxWaitTime = 0.0;
      gttbl[i].countWaitAvg = 0;
    }
  }
}


void printStats() {
  printf("\n\n                     Statistics\n");
	switch(stype) {
		case 1:
			printf("              Planovac: Round-Robin (RR)\n");
			break;
		case 2:
			printf("       Planovac: Round-Robin with priorities (PRI)\n");
			break;
		case 3:
			printf("          Planovac: Lottery Scheduling (LS)\n");
			break;
	}
  printf("\n");
  
  for (int i = 0; i < MaxGThreads; i++) {
    printf("                     Custom ID: %d\n", gttbl[i].thr_id);
    printf("                     Thread id: %d\n", i);
    switch(stype) {
      case 2:
        printf("                  Thread priority: %d\n", gttbl[i].priority);
        break;
      case 3:
        printf("               Thread tickets: %d - %d (%d)\n", gttbl[i].tickets[0], gttbl[i].tickets[1], (gttbl[i].tickets[1] - gttbl[i].tickets[0]) + 1);
        break;
    }
    printf("      Run                 |       Wait\n");
    printf("Total run time:  %f | Total wait time: %f\n", gttbl[i].totalRunTime, gttbl[i].totalWaitTime);
    printf(" Min. run time:  %f |  Min. wait time: %f\n", gttbl[i].minRunTime, gttbl[i].minWaitTime);
    printf(" Max. run time:  %f |  Max. wait time: %f\n", gttbl[i].maxRunTime, gttbl[i].maxWaitTime);
    printf(" Avg. run time:  %f |  Avg. wait time: %f\n", gttbl[i].totalRunTime / gttbl[i].countRunAvg, gttbl[i].totalWaitTime / gttbl[i].countWaitAvg);
    printf("\n");
  }
}